package com.nanothor.lifetc3.ui.utils;

import java.io.CharArrayReader;

import javax.swing.text.Segment;

import org.antlr.v4.runtime.ANTLRInputStream;
import org.antlr.v4.runtime.CommonTokenStream;
import org.fife.ui.rsyntaxtextarea.AbstractTokenMaker;
import org.fife.ui.rsyntaxtextarea.Token;
import org.fife.ui.rsyntaxtextarea.TokenMap;
import org.fife.ui.rsyntaxtextarea.TokenTypes;

import br.ufpi.compilers.firstcompiler.antlr4.AnalisysGrammarLexer;
import br.ufpi.compilers.firstcompiler.antlr4.Grammar01Lexer;

/**
 * Class ANTLRTokenMaker wraps a lexer generated by ANTLR to conform to the requirements of
 * a lexer (TokenMaker) used by RSyntaxTextArea.<p>
 * 
 *	Here's what's in an ANTLR token
 * <ul>
 * 	<li>		getText(): this is ONLY the chars in this token, as a String
 * 	<li>		getCharPositionInLine(): start of token in the original line
 *	<li>		getTokenIndex(): the sequence number of this token in the line, beginning with 0
 *	<li>		getTokenType(): the ANTLR lexer's token type constant
 *	<li>		getLine(): the line number where this token occurs; always 1 in this context because we are lexing one line at a time
 * </ul><p>
 * 
 * A lexer class generated by ANTLR defines a symbolic constant (in Java, a public static final int) for each token type specified
 * by the grammar. We can reference those constants as, for example, DemoLexer.RESERVED_WORD.<p>
 * 
 * 	Here's what's needed to create an RSTA token using method addToken:<p>
 *
 *		addToken(char[] array, int start, int end, int tokenType, int startOffset)<p>
 *		
 *		Parameters:
 * <ul>
 * 	<li>		array - the character array from which to get the text
 * 	<li>		start - start offset in segment of token
 * 	<li>		end - end offset in segment of token
 * 	<li>		tokenType - the token's type, as defined by RSTA; see interface TokenTypes
 * 	<li>		startOffset - the offset in the document at which this token occurs
 * </ul><p>
 *
 * Readers of the source code for this class may note that Plaid Flannel Software uses a form
 * of <a href="http://en.wikipedia.org/wiki/Hungarian_notation">Hungarian notation</a>
 * in which the first letter of a variable identifier indicates its use or provenance:
 * <ul>
 * <li> p - a method <b>P</b>arameter
 * <li> s - a <b>S</b>tatic class data member
 * <li> m - a class instance data <b>M</b>ember
 * <li> t - a <b>T</b>emporary or local variable within a method
 * <li> i - a loop <b>I</b>ndex variable
 * <li> d - a variable used only in <b>D</b>ebugging code
 * </ul><p>
 * 
 * The contents of this file is placed into the public domain as of February 27, 2012.<p>
 * 
 * @version Feb 27, 2012
 * @author  Gary Ford (Plaid Flannel Software)
 */

public class ANTLRTokenMaker
	extends AbstractTokenMaker
	implements TokenTypes
{
	// ————————————————————————————————————————
	// instance data members
	// ————————————————————————————————————————

	/** the lexer generated by ANTLR */
	private AnalisysGrammarLexer mANTLRLexer;

	// ————————————————————————————————————————
	// constructors
	// ————————————————————————————————————————

	// ————————————————————————————————————————
	/**
	 * Nullary constructor required by TokenMakerFactory.
	 */
	public ANTLRTokenMaker()
	{
		mANTLRLexer = new AnalisysGrammarLexer(null);
	} // end constructor

	// ————————————————————————————————————————
	// overrides of abstract methods from class AbstractTokenMaker
	// ————————————————————————————————————————

	// ————————————————————————————————————————
	/**
	 * Returns the first token in a linked list of tokens created by the lexer.
	 * <p>
	 * 
	 * This method expects to reuse an existing lexer of class DemoLexer; that class is
	 * created by running ANTLR on the DemoLexer.g grammar. 
	 * Note that this grammar does not make use of multiline comments or documentation
	 * comments, so the initial token type parameter is unused.<p>
	 * 
	 * This method is needed because of the difference in how ANTLR and JFlex lexers
	 * return their results: ANTLR uses a token stream, while JFlex uses a token linked list.<p>
	 * 
	 * @param pSegment
	 * 		the Segment from which the tokens are to be extracted
	 * @param pInitialTokenType
	 * 		the token-scanning state in which to start the scan (used primarily for multiline comments)
	 * @param pSegmentOffset
	 * 		the offset in the whole document where the list of tokens starts
	 * @return
	 * 		the first token in the linked list of tokens extracted from the Segment
	 */
	@Override
	public Token getTokenList(Segment pSegment, int pInitialTokenType, int pSegmentOffset)
	{
		try
		{
			// create a Reader for the characters in the given Segment
			CharArrayReader tReader = new CharArrayReader(pSegment.array, pSegment.offset, pSegment.count);

			// give that Reader to the ANTLR lexer for processing
			//mANTLRLexer.setCharStream(new ANTLRReaderStream(tReader));

			mANTLRLexer.setInputStream(new ANTLRInputStream(tReader));

			// get the resulting token stream from the lexer
			//CommonTokenStream tTokenStream = new CommonTokenStream(mANTLRLexer);
			CommonTokenStream tTokenStream = new CommonTokenStream(mANTLRLexer);

			resetTokenList(); // so we can create a fresh token list

			// retrieve and convert tokens one at a time; note that the stream returns the EOF token as the last token
			while (true)
			{
//				System.out.println("TOKENIZANDO");
				org.antlr.v4.runtime.Token tToken = tTokenStream.LT(1);
//				System.out.println("tToken: "+tToken.toString()+" | TYPE: "+tToken.getType());
				if (tToken.getType() == org.antlr.v4.runtime.Token.EOF)
					break;
				tTokenStream.consume();

				// convert the ANTLR token to a RSyntaxTextArea token and add it to the linked list
				int tRSTATokenStart = tToken.getCharPositionInLine() + pSegment.offset;
				int tRSTATokenEnd = tRSTATokenStart + tToken.getText().length() - 1;
				int tRSTATokenOffset = pSegmentOffset + tToken.getCharPositionInLine();
				
				addToken(pSegment.array, tRSTATokenStart, tRSTATokenEnd, convertTokenType(tToken.getType()), tRSTATokenOffset);

			} // end while

			// add a null token to indicate end of line; note that the test grammar has no multiline token types
			addNullToken();

		} // end try

		catch (Exception ex)
		{
			// quick fix for testing purposes
			System.out.println("Exception in ANTLRTokenMaker.getTokenList() " + ex.getMessage());

		} // end catch

		// return first node in the linked list
		return firstToken; // firstToken is declared in the superclass

	} // end getTokenList()

	// ————————————————————————————————————————
	/**
	 * This method is required, but it is not needed. Token types are sufficient to identify
	 * which tokens will be "highlighted".
	 */
	@Override
	public TokenMap getWordsToHighlight()
	{
		return wordsToHighlight; // wordsToHighlight is declared in the superclass

	} // end getWordsToHighlight()

	// ————————————————————————————————————————
	// internal methods
	// ————————————————————————————————————————

	// ————————————————————————————————————————
	/**
	 * Converts an ANTLR token type to an RSTA token type.<p>
	 * 
	 * The demo grammar used for testing ANTLRTokenMaker defines only those DemoLexer token types
	 * referenced below, and the SyntaxScheme used by the RSTA defines representations
	 * only for those RSTA token types referenced below.
	 * 
	 * @param pANTLRType
	 * 		the type code for an ANTLR token
	 * @return
	 * 		the type code for a corresponding RSTA token
	 */
	private int convertTokenType(int pANTLRType)
	{
		System.out.println("ANALIZANDO TOKEN DE TIPO: "+pANTLRType);
		if (pANTLRType == AnalisysGrammarLexer.WHITESPACE)
			return WHITESPACE;
		if (pANTLRType == AnalisysGrammarLexer.IDENTIFIER)
			return IDENTIFIER;
		if (pANTLRType == AnalisysGrammarLexer.RESERVED_WORD)
			return RESERVED_WORD;
		if (pANTLRType == AnalisysGrammarLexer.OPERATORS)
			return OPERATOR;
		if (pANTLRType == AnalisysGrammarLexer.PARENS)
			return MARKUP_CDATA_DELIMITER;
		if (pANTLRType == AnalisysGrammarLexer.LITERAL_INT)
			return LITERAL_NUMBER_DECIMAL_INT;
		if (pANTLRType == AnalisysGrammarLexer.LITERAL_FLOAT)
			return LITERAL_NUMBER_FLOAT;
//		if (pANTLRType == AnalisysGrammarLexer.)
//			return LITERAL_NUMBER_FLOAT;
		
//		if (pANTLRType == AnalisysGrammarLexer.STRING_LITERAL)
//			return LITERAL_STRING_DOUBLE_QUOTE;
//		
//		if (pANTLRType == DemoLexer.COMMENT_EOL)
//			return COMMENT_EOL;
//		
//		if (pANTLRType == DemoLexer.PARTIAL_STRING)
//			return ERROR_STRING_DOUBLE;
//		
		if (pANTLRType == AnalisysGrammarLexer.ANYCHAR)
			return ERROR_CHAR;
		
		return IDENTIFIER; // this is the default for demonstration purposes only

	} // end convertTokenType()

} // end class ANTLRTokenMaker
